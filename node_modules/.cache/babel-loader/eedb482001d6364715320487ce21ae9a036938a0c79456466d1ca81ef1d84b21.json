{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\HP\\\\Desktop\\\\ChatBotFlow\\\\bitespeed-flow-builder\\\\src\\\\components\\\\Canvas\\\\FlowCanvas.js\",\n  _s = $RefreshSig$();\nimport React, { useCallback, useRef } from 'react';\nimport ReactFlow, { addEdge, applyNodeChanges, applyEdgeChanges } from 'reactflow';\nimport 'reactflow/dist/style.css';\nimport { nanoid } from 'nanoid';\nimport { getDefaultNode } from '../../utils/nodeSchemas';\nimport TextNode from './nodes/TextNode';\nimport { useFlowState, useFlowDispatch } from '../../state/flowContext';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst nodeTypes = {\n  textNode: TextNode\n};\nexport default function FlowCanvas() {\n  _s();\n  const {\n    nodes,\n    edges\n  } = useFlowState();\n  const dispatch = useFlowDispatch();\n  const reactFlowWrapper = useRef(null);\n  const reactFlowInstance = useRef(null);\n\n  // Directly update context on node/edge changes\n  const onNodesChange = useCallback(changes => {\n    dispatch({\n      type: 'LOAD_FLOW',\n      nodes: applyNodeChanges(changes, nodes),\n      edges\n    });\n  }, [dispatch, nodes, edges]);\n  const onEdgesChange = useCallback(changes => {\n    dispatch({\n      type: 'LOAD_FLOW',\n      nodes,\n      edges: applyEdgeChanges(changes, edges)\n    });\n  }, [dispatch, nodes, edges]);\n  const onConnect = useCallback(params => {\n    // enforce single outbound per source handle\n    const exists = edges.some(e => e.source === params.source && e.sourceHandle === params.sourceHandle);\n    if (exists) {\n      alert('Each source handle may only have one outbound connection');\n      return;\n    }\n    const newEdge = addEdge({\n      ...params,\n      id: 'e' + nanoid()\n    }, edges);\n    dispatch({\n      type: 'LOAD_FLOW',\n      nodes,\n      edges: newEdge\n    });\n  }, [edges, nodes, dispatch]);\n  const onNodeClick = useCallback((event, node) => {\n    dispatch({\n      type: 'SET_SELECTED',\n      id: node.id\n    });\n  }, [dispatch]);\n  const onDrop = useCallback(event => {\n    var _reactFlowWrapper$cur;\n    event.preventDefault();\n    const reactFlowType = event.dataTransfer.getData('application/reactflow');\n    if (!reactFlowType) return;\n    const bounds = ((_reactFlowWrapper$cur = reactFlowWrapper.current) === null || _reactFlowWrapper$cur === void 0 ? void 0 : _reactFlowWrapper$cur.getBoundingClientRect()) || {\n      left: 0,\n      top: 0\n    };\n    const point = {\n      x: event.clientX - bounds.left,\n      y: event.clientY - bounds.top\n    };\n    let nodePosition = point;\n    if (reactFlowInstance !== null && reactFlowInstance !== void 0 && reactFlowInstance.current && typeof reactFlowInstance.current.project === 'function') {\n      nodePosition = reactFlowInstance.current.project(point);\n    }\n    if (!nodePosition || isNaN(Number(nodePosition.x)) || isNaN(Number(nodePosition.y))) {\n      nodePosition = {\n        x: 200,\n        y: 100\n      };\n    }\n    const id = nanoid();\n    const newNode = getDefaultNode(reactFlowType, id, nodePosition);\n    dispatch({\n      type: 'LOAD_FLOW',\n      nodes: [...nodes, newNode],\n      edges\n    });\n  }, [nodes, edges, dispatch]);\n  const onDragOver = useCallback(event => event.preventDefault(), []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: reactFlowWrapper,\n    style: {\n      width: '100%',\n      height: '100%'\n    },\n    onDrop: onDrop,\n    onDragOver: onDragOver,\n    children: /*#__PURE__*/_jsxDEV(ReactFlow, {\n      nodes: nodes,\n      edges: edges,\n      onNodesChange: onNodesChange,\n      onEdgesChange: onEdgesChange,\n      onConnect: onConnect,\n      nodeTypes: nodeTypes,\n      onNodeClick: onNodeClick,\n      onInit: instance => reactFlowInstance.current = instance,\n      fitView: true\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 75,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 74,\n    columnNumber: 5\n  }, this);\n}\n_s(FlowCanvas, \"wOBq5IFsz+kZcKX/1henQ/Vk+ms=\", false, function () {\n  return [useFlowState, useFlowDispatch];\n});\n_c = FlowCanvas;\nvar _c;\n$RefreshReg$(_c, \"FlowCanvas\");","map":{"version":3,"names":["React","useCallback","useRef","ReactFlow","addEdge","applyNodeChanges","applyEdgeChanges","nanoid","getDefaultNode","TextNode","useFlowState","useFlowDispatch","jsxDEV","_jsxDEV","nodeTypes","textNode","FlowCanvas","_s","nodes","edges","dispatch","reactFlowWrapper","reactFlowInstance","onNodesChange","changes","type","onEdgesChange","onConnect","params","exists","some","e","source","sourceHandle","alert","newEdge","id","onNodeClick","event","node","onDrop","_reactFlowWrapper$cur","preventDefault","reactFlowType","dataTransfer","getData","bounds","current","getBoundingClientRect","left","top","point","x","clientX","y","clientY","nodePosition","project","isNaN","Number","newNode","onDragOver","ref","style","width","height","children","onInit","instance","fitView","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/HP/Desktop/ChatBotFlow/bitespeed-flow-builder/src/components/Canvas/FlowCanvas.js"],"sourcesContent":["import React, { useCallback, useRef } from 'react'\r\nimport ReactFlow, { addEdge, applyNodeChanges, applyEdgeChanges } from 'reactflow'\r\nimport 'reactflow/dist/style.css'\r\nimport { nanoid } from 'nanoid'\r\nimport { getDefaultNode } from '../../utils/nodeSchemas'\r\nimport TextNode from './nodes/TextNode'\r\nimport { useFlowState, useFlowDispatch } from '../../state/flowContext'\r\n\r\nconst nodeTypes = { textNode: TextNode }\r\n\r\nexport default function FlowCanvas() {\r\n  const { nodes, edges } = useFlowState()\r\n  const dispatch = useFlowDispatch()\r\n  const reactFlowWrapper = useRef(null)\r\n  const reactFlowInstance = useRef(null)\r\n\r\n  // Directly update context on node/edge changes\r\n  const onNodesChange = useCallback(\r\n    changes => {\r\n      dispatch({ type: 'LOAD_FLOW', nodes: applyNodeChanges(changes, nodes), edges })\r\n    },\r\n    [dispatch, nodes, edges],\r\n  )\r\n\r\n  const onEdgesChange = useCallback(\r\n    changes => {\r\n      dispatch({ type: 'LOAD_FLOW', nodes, edges: applyEdgeChanges(changes, edges) })\r\n    },\r\n    [dispatch, nodes, edges],\r\n  )\r\n\r\n  const onConnect = useCallback(\r\n    params => {\r\n      // enforce single outbound per source handle\r\n      const exists = edges.some(e => e.source === params.source && e.sourceHandle === params.sourceHandle)\r\n      if (exists) {\r\n        alert('Each source handle may only have one outbound connection')\r\n        return\r\n      }\r\n      const newEdge = addEdge({ ...params, id: 'e' + nanoid() }, edges)\r\n      dispatch({ type: 'LOAD_FLOW', nodes, edges: newEdge })\r\n    },\r\n    [edges, nodes, dispatch],\r\n  )\r\n\r\n  const onNodeClick = useCallback((event, node) => {\r\n    dispatch({ type: 'SET_SELECTED', id: node.id })\r\n  }, [dispatch])\r\n\r\n  const onDrop = useCallback(\r\n    event => {\r\n      event.preventDefault()\r\n      const reactFlowType = event.dataTransfer.getData('application/reactflow')\r\n      if (!reactFlowType) return\r\n      const bounds = reactFlowWrapper.current?.getBoundingClientRect() || { left: 0, top: 0 }\r\n      const point = { x: event.clientX - bounds.left, y: event.clientY - bounds.top }\r\n      let nodePosition = point\r\n      if (reactFlowInstance?.current && typeof reactFlowInstance.current.project === 'function') {\r\n        nodePosition = reactFlowInstance.current.project(point)\r\n      }\r\n      if (!nodePosition || isNaN(Number(nodePosition.x)) || isNaN(Number(nodePosition.y))) {\r\n        nodePosition = { x: 200, y: 100 }\r\n      }\r\n      const id = nanoid()\r\n      const newNode = getDefaultNode(reactFlowType, id, nodePosition)\r\n      dispatch({ type: 'LOAD_FLOW', nodes: [...nodes, newNode], edges })\r\n    },\r\n    [nodes, edges, dispatch],\r\n  )\r\n\r\n  const onDragOver = useCallback(event => event.preventDefault(), [])\r\n\r\n  return (\r\n    <div ref={reactFlowWrapper} style={{ width: '100%', height: '100%' }} onDrop={onDrop} onDragOver={onDragOver}>\r\n      <ReactFlow\r\n        nodes={nodes}\r\n        edges={edges}\r\n        onNodesChange={onNodesChange}\r\n        onEdgesChange={onEdgesChange}\r\n        onConnect={onConnect}\r\n        nodeTypes={nodeTypes}\r\n        onNodeClick={onNodeClick}\r\n        onInit={instance => (reactFlowInstance.current = instance)}\r\n        fitView\r\n      />\r\n    </div>\r\n  )\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}