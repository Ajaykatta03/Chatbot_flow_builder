{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\HP\\\\Desktop\\\\ChatBotFlow\\\\bitespeed-flow-builder\\\\src\\\\components\\\\Canvas\\\\FlowCanvas.js\",\n  _s = $RefreshSig$();\nimport React, { useCallback, useRef } from 'react';\nimport ReactFlow, { addEdge, useNodesState, useEdgesState } from 'reactflow';\nimport 'reactflow/dist/style.css';\nimport { nanoid } from 'nanoid';\nimport { getDefaultNode } from '../../utils/nodeSchemas';\nimport TextNode from './nodes/TextNode';\nimport { useFlowState, useFlowDispatch } from '../../state/flowContext';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst nodeTypes = {\n  textNode: TextNode\n};\nexport default function FlowCanvas() {\n  _s();\n  const {\n    nodes: ctxNodes,\n    edges: ctxEdges\n  } = useFlowState();\n  const dispatch = useFlowDispatch();\n\n  // keep local react-flow states synced with global context for simplicity\n  const [nodes, setNodes, onNodesChange] = useNodesState(ctxNodes);\n  const [edges, setEdges, onEdgesChange] = useEdgesState(ctxEdges);\n\n  // when react-flow nodes/edges change, update global state\n  const syncToContext = useCallback((ns, es) => {\n    // naive sync: replace entire arrays\n    dispatch({\n      type: 'LOAD_FLOW',\n      nodes: ns,\n      edges: es\n    });\n  }, [dispatch]);\n  const onConnect = useCallback(params => {\n    // enforce single outbound per source handle\n    const exists = edges.some(e => e.source === params.source && e.sourceHandle === params.sourceHandle);\n    if (exists) {\n      alert('Each source handle may only have one outbound connection');\n      return;\n    }\n    const newEdge = addEdge({\n      ...params,\n      id: 'e' + nanoid()\n    }, edges);\n    setEdges(newEdge);\n    syncToContext(nodes, newEdge);\n  }, [edges, setEdges, syncToContext, nodes]);\n  const onDrop = useCallback(event => {\n    event.preventDefault();\n    const reactFlowType = event.dataTransfer.getData('application/reactflow');\n    if (!reactFlowType) return;\n    const bounds = event.target.getBoundingClientRect();\n    const position = {\n      x: event.clientX - bounds.left,\n      y: event.clientY - bounds.top\n    };\n    const id = nanoid();\n    const newNode = getDefaultNode(reactFlowType, id, position);\n    const ns = nodes.concat(newNode);\n    setNodes(ns);\n    syncToContext(ns, edges);\n  }, [edges, nodes, setEdges, setNodes, syncToContext]);\n  const onDragOver = useCallback(event => event.preventDefault(), []);\n\n  // when local nodes/edges change via reactflow hooks, sync to context\n  React.useEffect(() => syncToContext(nodes, edges), [nodes, edges, syncToContext]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      width: '100%',\n      height: '100%'\n    },\n    onDrop: onDrop,\n    onDragOver: onDragOver,\n    children: /*#__PURE__*/_jsxDEV(ReactFlow, {\n      nodes: nodes,\n      edges: edges,\n      onNodesChange: onNodesChange,\n      onEdgesChange: onEdgesChange,\n      onConnect: onConnect,\n      nodeTypes: nodeTypes,\n      fitView: true\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 67,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 66,\n    columnNumber: 5\n  }, this);\n}\n_s(FlowCanvas, \"9kYlFMaUlXfV0rbtuRrL/wguw1o=\", false, function () {\n  return [useFlowState, useFlowDispatch, useNodesState, useEdgesState];\n});\n_c = FlowCanvas;\nvar _c;\n$RefreshReg$(_c, \"FlowCanvas\");","map":{"version":3,"names":["React","useCallback","useRef","ReactFlow","addEdge","useNodesState","useEdgesState","nanoid","getDefaultNode","TextNode","useFlowState","useFlowDispatch","jsxDEV","_jsxDEV","nodeTypes","textNode","FlowCanvas","_s","nodes","ctxNodes","edges","ctxEdges","dispatch","setNodes","onNodesChange","setEdges","onEdgesChange","syncToContext","ns","es","type","onConnect","params","exists","some","e","source","sourceHandle","alert","newEdge","id","onDrop","event","preventDefault","reactFlowType","dataTransfer","getData","bounds","target","getBoundingClientRect","position","x","clientX","left","y","clientY","top","newNode","concat","onDragOver","useEffect","style","width","height","children","fitView","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/HP/Desktop/ChatBotFlow/bitespeed-flow-builder/src/components/Canvas/FlowCanvas.js"],"sourcesContent":["import React, { useCallback, useRef } from 'react'\r\nimport ReactFlow, { addEdge, useNodesState, useEdgesState } from 'reactflow'\r\nimport 'reactflow/dist/style.css'\r\nimport { nanoid } from 'nanoid'\r\nimport { getDefaultNode } from '../../utils/nodeSchemas'\r\nimport TextNode from './nodes/TextNode'\r\nimport { useFlowState, useFlowDispatch } from '../../state/flowContext'\r\n\r\nconst nodeTypes = { textNode: TextNode }\r\n\r\nexport default function FlowCanvas() {\r\n  const { nodes: ctxNodes, edges: ctxEdges } = useFlowState()\r\n  const dispatch = useFlowDispatch()\r\n\r\n  // keep local react-flow states synced with global context for simplicity\r\n  const [nodes, setNodes, onNodesChange] = useNodesState(ctxNodes)\r\n  const [edges, setEdges, onEdgesChange] = useEdgesState(ctxEdges)\r\n\r\n  // when react-flow nodes/edges change, update global state\r\n  const syncToContext = useCallback(\r\n    (ns, es) => {\r\n      // naive sync: replace entire arrays\r\n      dispatch({ type: 'LOAD_FLOW', nodes: ns, edges: es })\r\n    },\r\n    [dispatch],\r\n  )\r\n\r\n  const onConnect = useCallback(\r\n    params => {\r\n      // enforce single outbound per source handle\r\n      const exists = edges.some(e => e.source === params.source && e.sourceHandle === params.sourceHandle)\r\n      if (exists) {\r\n        alert('Each source handle may only have one outbound connection')\r\n        return\r\n      }\r\n      const newEdge = addEdge({ ...params, id: 'e' + nanoid() }, edges)\r\n      setEdges(newEdge)\r\n      syncToContext(nodes, newEdge)\r\n    },\r\n    [edges, setEdges, syncToContext, nodes],\r\n  )\r\n\r\n  const onDrop = useCallback(\r\n    event => {\r\n      event.preventDefault()\r\n      const reactFlowType = event.dataTransfer.getData('application/reactflow')\r\n      if (!reactFlowType) return\r\n\r\n      const bounds = event.target.getBoundingClientRect()\r\n      const position = { x: event.clientX - bounds.left, y: event.clientY - bounds.top }\r\n      const id = nanoid()\r\n      const newNode = getDefaultNode(reactFlowType, id, position)\r\n      const ns = nodes.concat(newNode)\r\n      setNodes(ns)\r\n      syncToContext(ns, edges)\r\n    },\r\n    [edges, nodes, setEdges, setNodes, syncToContext],\r\n  )\r\n\r\n  const onDragOver = useCallback(event => event.preventDefault(), [])\r\n\r\n  // when local nodes/edges change via reactflow hooks, sync to context\r\n  React.useEffect(() => syncToContext(nodes, edges), [nodes, edges, syncToContext])\r\n\r\n  return (\r\n    <div style={{ width: '100%', height: '100%' }} onDrop={onDrop} onDragOver={onDragOver}>\r\n      <ReactFlow nodes={nodes} edges={edges} onNodesChange={onNodesChange} onEdgesChange={onEdgesChange} onConnect={onConnect} nodeTypes={nodeTypes} fitView />\r\n    </div>\r\n  )\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}