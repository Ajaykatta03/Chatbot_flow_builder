{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\HP\\\\Desktop\\\\ChatBotFlow\\\\bitespeed-flow-builder\\\\src\\\\components\\\\Canvas\\\\FlowCanvas.js\",\n  _s = $RefreshSig$();\nimport React, { useCallback, useRef } from 'react';\nimport ReactFlow, { addEdge, useNodesState, useEdgesState } from 'reactflow';\nimport 'reactflow/dist/style.css';\nimport { nanoid } from 'nanoid';\nimport { getDefaultNode } from '../../utils/nodeSchemas';\nimport TextNode from './nodes/TextNode';\nimport { useFlowState, useFlowDispatch } from '../../state/flowContext';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst nodeTypes = {\n  textNode: TextNode\n};\nexport default function FlowCanvas() {\n  _s();\n  const {\n    nodes: ctxNodes,\n    edges: ctxEdges\n  } = useFlowState();\n  const dispatch = useFlowDispatch();\n\n  // keep local react-flow states synced with global context for simplicity\n  const [nodes, setNodes, onNodesChange] = useNodesState(ctxNodes);\n  const [edges, setEdges, onEdgesChange] = useEdgesState(ctxEdges);\n\n  // when react-flow nodes/edges change, update global state\n  const syncToContext = useCallback((ns, es) => {\n    // avoid dispatching if nothing changed to prevent loops\n    try {\n      const sameNodes = JSON.stringify(ctxNodes) === JSON.stringify(ns);\n      const sameEdges = JSON.stringify(ctxEdges) === JSON.stringify(es);\n      if (sameNodes && sameEdges) return;\n    } catch (err) {\n      // fallthrough to dispatch if stringify fails\n    }\n    dispatch({\n      type: 'LOAD_FLOW',\n      nodes: ns,\n      edges: es\n    });\n  }, [dispatch, ctxNodes, ctxEdges]);\n  const onConnect = useCallback(params => {\n    // enforce single outbound per source handle\n    const exists = edges.some(e => e.source === params.source && e.sourceHandle === params.sourceHandle);\n    if (exists) {\n      alert('Each source handle may only have one outbound connection');\n      return;\n    }\n    const newEdge = addEdge({\n      ...params,\n      id: 'e' + nanoid()\n    }, edges);\n    setEdges(newEdge);\n    syncToContext(nodes, newEdge);\n  }, [edges, setEdges, syncToContext, nodes]);\n  const onNodeClick = useCallback((event, node) => {\n    // set selected node in global state so SettingsPanel shows\n    dispatch({\n      type: 'SET_SELECTED',\n      id: node.id\n    });\n  }, [dispatch]);\n  const reactFlowWrapper = useRef(null);\n  const reactFlowInstance = useRef(null);\n  const onDrop = useCallback(event => {\n    var _reactFlowWrapper$cur;\n    event.preventDefault();\n    const reactFlowType = event.dataTransfer.getData('application/reactflow');\n    if (!reactFlowType) return;\n    const bounds = ((_reactFlowWrapper$cur = reactFlowWrapper.current) === null || _reactFlowWrapper$cur === void 0 ? void 0 : _reactFlowWrapper$cur.getBoundingClientRect()) || {\n      left: 0,\n      top: 0\n    };\n    const point = {\n      x: event.clientX - bounds.left,\n      y: event.clientY - bounds.top\n    };\n    let nodePosition = point;\n    if (reactFlowInstance !== null && reactFlowInstance !== void 0 && reactFlowInstance.current && typeof reactFlowInstance.current.project === 'function') {\n      nodePosition = reactFlowInstance.current.project(point);\n    }\n    // fallback: if position is invalid, use center of canvas\n    if (!nodePosition || isNaN(Number(nodePosition.x)) || isNaN(Number(nodePosition.y))) {\n      nodePosition = {\n        x: 200,\n        y: 100\n      };\n    }\n    const id = nanoid();\n    const newNode = getDefaultNode(reactFlowType, id, nodePosition);\n    setNodes(nds => nds.concat(newNode));\n    syncToContext([...nodes, newNode], edges);\n  }, [edges, nodes, setNodes, syncToContext]);\n  const onDragOver = useCallback(event => event.preventDefault(), []);\n\n  // when local nodes/edges change via reactflow hooks, sync to context\n  React.useEffect(() => syncToContext(nodes, edges), [nodes, edges, syncToContext]);\n\n  // keep local react-flow state in sync when context changes (e.g. editing in SettingsPanel)\n  React.useEffect(() => {\n    try {\n      if (JSON.stringify(ctxNodes) !== JSON.stringify(nodes)) setNodes(ctxNodes);\n    } catch (err) {\n      setNodes(ctxNodes);\n    }\n  }, [ctxNodes, nodes, setNodes]);\n  React.useEffect(() => {\n    try {\n      if (JSON.stringify(ctxEdges) !== JSON.stringify(edges)) setEdges(ctxEdges);\n    } catch (err) {\n      setEdges(ctxEdges);\n    }\n  }, [ctxEdges, edges, setEdges]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: reactFlowWrapper,\n    style: {\n      width: '100%',\n      height: '100%'\n    },\n    onDrop: onDrop,\n    onDragOver: onDragOver,\n    children: /*#__PURE__*/_jsxDEV(ReactFlow, {\n      nodes: nodes,\n      edges: edges,\n      onNodesChange: onNodesChange,\n      onEdgesChange: onEdgesChange,\n      onConnect: onConnect,\n      nodeTypes: nodeTypes,\n      onNodeClick: onNodeClick,\n      onInit: instance => reactFlowInstance.current = instance,\n      fitView: true\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 106,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 105,\n    columnNumber: 5\n  }, this);\n}\n_s(FlowCanvas, \"oBYkK4wRmcXgDkYvYsKXtYvb0V4=\", false, function () {\n  return [useFlowState, useFlowDispatch, useNodesState, useEdgesState];\n});\n_c = FlowCanvas;\nvar _c;\n$RefreshReg$(_c, \"FlowCanvas\");","map":{"version":3,"names":["React","useCallback","useRef","ReactFlow","addEdge","useNodesState","useEdgesState","nanoid","getDefaultNode","TextNode","useFlowState","useFlowDispatch","jsxDEV","_jsxDEV","nodeTypes","textNode","FlowCanvas","_s","nodes","ctxNodes","edges","ctxEdges","dispatch","setNodes","onNodesChange","setEdges","onEdgesChange","syncToContext","ns","es","sameNodes","JSON","stringify","sameEdges","err","type","onConnect","params","exists","some","e","source","sourceHandle","alert","newEdge","id","onNodeClick","event","node","reactFlowWrapper","reactFlowInstance","onDrop","_reactFlowWrapper$cur","preventDefault","reactFlowType","dataTransfer","getData","bounds","current","getBoundingClientRect","left","top","point","x","clientX","y","clientY","nodePosition","project","isNaN","Number","newNode","nds","concat","onDragOver","useEffect","ref","style","width","height","children","onInit","instance","fitView","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/HP/Desktop/ChatBotFlow/bitespeed-flow-builder/src/components/Canvas/FlowCanvas.js"],"sourcesContent":["import React, { useCallback, useRef } from 'react'\r\nimport ReactFlow, { addEdge, useNodesState, useEdgesState } from 'reactflow'\r\nimport 'reactflow/dist/style.css'\r\nimport { nanoid } from 'nanoid'\r\nimport { getDefaultNode } from '../../utils/nodeSchemas'\r\nimport TextNode from './nodes/TextNode'\r\nimport { useFlowState, useFlowDispatch } from '../../state/flowContext'\r\n\r\nconst nodeTypes = { textNode: TextNode }\r\n\r\nexport default function FlowCanvas() {\r\n  const { nodes: ctxNodes, edges: ctxEdges } = useFlowState()\r\n  const dispatch = useFlowDispatch()\r\n\r\n  // keep local react-flow states synced with global context for simplicity\r\n  const [nodes, setNodes, onNodesChange] = useNodesState(ctxNodes)\r\n  const [edges, setEdges, onEdgesChange] = useEdgesState(ctxEdges)\r\n\r\n  // when react-flow nodes/edges change, update global state\r\n  const syncToContext = useCallback(\r\n    (ns, es) => {\r\n      // avoid dispatching if nothing changed to prevent loops\r\n      try {\r\n        const sameNodes = JSON.stringify(ctxNodes) === JSON.stringify(ns)\r\n        const sameEdges = JSON.stringify(ctxEdges) === JSON.stringify(es)\r\n        if (sameNodes && sameEdges) return\r\n      } catch (err) {\r\n        // fallthrough to dispatch if stringify fails\r\n      }\r\n      dispatch({ type: 'LOAD_FLOW', nodes: ns, edges: es })\r\n    },\r\n    [dispatch, ctxNodes, ctxEdges],\r\n  )\r\n\r\n  const onConnect = useCallback(\r\n    params => {\r\n      // enforce single outbound per source handle\r\n      const exists = edges.some(e => e.source === params.source && e.sourceHandle === params.sourceHandle)\r\n      if (exists) {\r\n        alert('Each source handle may only have one outbound connection')\r\n        return\r\n      }\r\n      const newEdge = addEdge({ ...params, id: 'e' + nanoid() }, edges)\r\n      setEdges(newEdge)\r\n      syncToContext(nodes, newEdge)\r\n    },\r\n    [edges, setEdges, syncToContext, nodes],\r\n  )\r\n\r\n  const onNodeClick = useCallback((event, node) => {\r\n    // set selected node in global state so SettingsPanel shows\r\n    dispatch({ type: 'SET_SELECTED', id: node.id })\r\n  }, [dispatch])\r\n\r\n  const reactFlowWrapper = useRef(null)\r\n  const reactFlowInstance = useRef(null)\r\n\r\n  const onDrop = useCallback(\r\n    event => {\r\n      event.preventDefault()\r\n      const reactFlowType = event.dataTransfer.getData('application/reactflow')\r\n      if (!reactFlowType) return\r\n\r\n      const bounds = reactFlowWrapper.current?.getBoundingClientRect() || { left: 0, top: 0 }\r\n      const point = { x: event.clientX - bounds.left, y: event.clientY - bounds.top }\r\n      let nodePosition = point\r\n      if (reactFlowInstance?.current && typeof reactFlowInstance.current.project === 'function') {\r\n        nodePosition = reactFlowInstance.current.project(point)\r\n      }\r\n      // fallback: if position is invalid, use center of canvas\r\n      if (!nodePosition || isNaN(Number(nodePosition.x)) || isNaN(Number(nodePosition.y))) {\r\n        nodePosition = { x: 200, y: 100 }\r\n      }\r\n      const id = nanoid()\r\n      const newNode = getDefaultNode(reactFlowType, id, nodePosition)\r\n      setNodes(nds => nds.concat(newNode))\r\n      syncToContext([...nodes, newNode], edges)\r\n    },\r\n    [edges, nodes, setNodes, syncToContext],\r\n  )\r\n\r\n  const onDragOver = useCallback(event => event.preventDefault(), [])\r\n\r\n  // when local nodes/edges change via reactflow hooks, sync to context\r\n  React.useEffect(() => syncToContext(nodes, edges), [nodes, edges, syncToContext])\r\n\r\n  // keep local react-flow state in sync when context changes (e.g. editing in SettingsPanel)\r\n  React.useEffect(() => {\r\n    try {\r\n      if (JSON.stringify(ctxNodes) !== JSON.stringify(nodes)) setNodes(ctxNodes)\r\n    } catch (err) {\r\n      setNodes(ctxNodes)\r\n    }\r\n  }, [ctxNodes, nodes, setNodes])\r\n\r\n  React.useEffect(() => {\r\n    try {\r\n      if (JSON.stringify(ctxEdges) !== JSON.stringify(edges)) setEdges(ctxEdges)\r\n    } catch (err) {\r\n      setEdges(ctxEdges)\r\n    }\r\n  }, [ctxEdges, edges, setEdges])\r\n\r\n  return (\r\n    <div ref={reactFlowWrapper} style={{ width: '100%', height: '100%' }} onDrop={onDrop} onDragOver={onDragOver}>\r\n      <ReactFlow\r\n        nodes={nodes}\r\n        edges={edges}\r\n        onNodesChange={onNodesChange}\r\n        onEdgesChange={onEdgesChange}\r\n        onConnect={onConnect}\r\n        nodeTypes={nodeTypes}\r\n        onNodeClick={onNodeClick}\r\n        onInit={instance => (reactFlowInstance.current = instance)}\r\n        fitView\r\n      />\r\n    </div>\r\n  )\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}